# -*- coding: utf-8 -*-
"""ENGINE LAYER.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1De_KA-dUY99JvldrYVRZibPQ9V7gdONe
"""

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import geopandas as gpd
import pandas as pd
import numpy as np
import networkx as nx
import libpysal as lp
from sklearn.neighbors import BallTree
from shapely.geometry import Point, MultiPoint
from matplotlib.lines import Line2D
from esda.moran import Moran

def run_analysis(facilities_df, roads_df, lga_boundary, outpatient_files, population_tif):
    """
    Unified Engine: Handles multi-year legacy (.xls) and modern (.xlsx) Excel files,
    standardizes LGA names, and performs spatial gap analysis.
    """
    try:
        # 1. Load and Merge Multi-Year Outpatient Data
        all_data = []
        files_to_process = outpatient_files if isinstance(outpatient_files, list) else [outpatient_files]

        for file in files_to_process:
            # FIX: Explicitly select engine based on file extension to prevent xlrd errors
            if file.name.endswith('.xls'):
                df = pd.read_excel(file, engine='xlrd')
            else:
                df = pd.read_excel(file, engine='openpyxl')
            all_data.append(df)
        
        if not all_data:
            return gpd.GeoDataFrame(), "No outpatient data uploaded."

        merged_data = pd.concat(all_data, ignore_index=True)

        # 2. Data Cleaning & Standardization
        # Standardize LGA names to match spatial boundary data (removes "kd" prefix and state total rows)
        merged_data["LGA"] = (
            merged_data["LGA"]
            .str.replace("^kd\s+", "", regex=True)
            .str.replace("Kaduna State", "State Total", regex=False)
            .str.replace("Local Government Area", "", regex=False)
            .str.strip()
        )

        # 3. Spatial Accessibility Analysis
        # Projecting to UTM Zone 32N (EPSG:32632) for accurate metric distance calculations
        roads_metric = roads_df.to_crs(epsg=32632)
        facilities_metric = facilities_df.to_crs(epsg=32632)
        lga_metric = lga_boundary.to_crs(epsg=32632)

        # Create a 30km buffer around all facilities (Proxy for 60-min travel time)
        coverage_60min = facilities_metric.geometry.buffer(30000).union_all()
        coverage_df = gpd.GeoDataFrame(geometry=[coverage_60min], crs=32632).to_crs(epsg=4326)

        # Identify 'Healthcare Deserts' - regions within LGA boundaries not covered by buffers
        healthcare_deserts = gpd.overlay(
            lga_boundary.to_crs(epsg=4326),
            coverage_df,
            how='difference'
        )

        results = "Analysis Complete: All annual datasets merged and spatial gaps calculated."
        
        return healthcare_deserts, results

    except Exception as e:
        # Safety net to prevent "TypeError: cannot unpack non-iterable NoneType object" in app_py.py
        st.error(f"Engine Error: {str(e)}")
        return gpd.GeoDataFrame(), f"Error: {str(e)}"

def calculate_priority_recommendations(lga_boundary, healthcare_deserts):
    """
    Ranks LGAs by underserved area and extracts coordinate centroids for new PHC sites.
    """
    try:
        if healthcare_deserts.empty:
            return pd.DataFrame(), []

        # Project to metric for accurate area (km2) measurements
        lga_proj = lga_boundary.to_crs(epsg=32632)
        deserts_proj = healthcare_deserts.to_crs(epsg=32632)

        priority_data = []
        # Identify the correct name column (NAME_2 is common for GADM, LGA_NAME for local files)
        name_col = 'NAME_2' if 'NAME_2' in lga_proj.columns else lga_proj.columns[0]

        for _, lga in lga_proj.iterrows():
            # Clip desert geometry to the specific LGA boundary
            lga_gap = deserts_proj.clip(lga.geometry)
            gap_area_km2 = lga_gap.area.sum() / 1e6 # Convert Square Meters to Square Kilometers

            status = "ðŸ”´ HIGH" if gap_area_km2 > 500 else "ðŸŸ¡ MEDIUM" if gap_area_km2 > 150 else "ðŸŸ¢ LOW"
            
            priority_data.append({
                "LGA Name": lga[name_col],
                "Underserved Area (kmÂ²)": round(gap_area_km2, 2),
                "Priority Status": status
            })

        priority_df = pd.DataFrame(priority_data).sort_values(by="Underserved Area (kmÂ²)", ascending=False)

        # Calculate Suggested GPS Locations
        deserts_exploded = healthcare_deserts.explode(index_parts=False)
        top_5_gaps = deserts_exploded.sort_values(by=deserts_exploded.area, ascending=False).head(5)

        proposed_sites = []
        for i, geom in enumerate(top_5_gaps.geometry):
            proposed_sites.append({
                "Proposed Site": f"Location {i+1}",
                "Latitude": round(geom.centroid.y, 6),
                "Longitude": round(geom.centroid.x, 6)
            })

        return priority_df, proposed_sites

    except Exception as e:
        st.error(f"Recommendation Error: {str(e)}")
        return pd.DataFrame(), []
