# -*- coding: utf-8 -*-
"""ENGINE LAYER.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1De_KA-dUY99JvldrYVRZibPQ9V7gdONe
"""

import streamlit as st
import geopandas as gpd
import pandas as pd
import numpy as np
import re
from shapely.geometry import Point

def run_analysis(facilities_df, roads_df, lga_boundary, outpatient_files, population_tif):
    """
    Unified Engine: Processes multi-year data, extracts years from filenames 
    if missing, and performs spatial accessibility gap analysis.
    """
    try:
        all_data = []
        # Ensure we treat input as a list even if only one file is uploaded
        files_to_process = outpatient_files if isinstance(outpatient_files, list) else [outpatient_files]

        for file in files_to_process:
            # 1. Load file with correct engine based on extension
            if file.name.endswith('.xls'):
                df = pd.read_excel(file, engine='xlrd')
            else:
                df = pd.read_excel(file, engine='openpyxl')
            
            # 2. Fix 'Year' column if missing by extracting from filename
            if 'Year' not in df.columns:
                # Extracts 4 digits (e.g., '2022' from 'Outpatient_2022.xls')
                year_match = re.search(r'(\d{4})', file.name)
                df['Year'] = int(year_match.group(1)) if year_match else 2024
            
            all_data.append(df)
        
        if not all_data:
            return gpd.GeoDataFrame(), "No data loaded."

        merged_data = pd.concat(all_data, ignore_index=True)

        # 3. Standardize columns and LGA names
        merged_data["LGA"] = (
            merged_data["LGA"]
            .astype(str)
            .str.replace("^kd\s+", "", regex=True)
            .str.replace("Kaduna State", "State Total", regex=False)
            .str.strip()
        )

        # 4. Spatial Accessibility (Simplified 30km Buffer)
        # Projecting to metric system for Kaduna (UTM 32N / EPSG:32632)
        facilities_metric = facilities_df.to_crs(epsg=32632)
        lga_metric = lga_boundary.to_crs(epsg=32632)

        # Create 30km coverage (Proxy for 60-min travel)
        # union_all() ensures we have one continuous coverage shape
        coverage_geom = facilities_metric.geometry.buffer(30000).union_all()
        coverage_df = gpd.GeoDataFrame(geometry=[coverage_geom], crs=32632).to_crs(epsg=4326)

        # Calculate Healthcare Deserts (Areas within LGAs NOT covered by the buffer)
        healthcare_deserts = gpd.overlay(
            lga_boundary.to_crs(epsg=4326),
            coverage_df,
            how='difference'
        )

        return healthcare_deserts, "Analysis Complete: Data merged and gaps identified."

    except Exception as e:
        # Safety net to prevent UI crashes if analysis fails
        st.error(f"Critical Engine Error: {str(e)}")
        return gpd.GeoDataFrame(), f"Error: {str(e)}"

def calculate_priority_recommendations(lga_boundary, healthcare_deserts):
    """
    Ranks LGAs by underserved area and identifies optimal centroids for new sites.
    """
    try:
        if healthcare_deserts.empty:
            return pd.DataFrame(columns=["LGA Name", "Underserved Area (kmÂ²)", "Priority Status"]), []

        lga_proj = lga_boundary.to_crs(epsg=32632)
        deserts_proj = healthcare_deserts.to_crs(epsg=32632)

        priority_data = []
        # Standard column check for GADM/State boundaries
        name_col = 'NAME_2' if 'NAME_2' in lga_proj.columns else lga_proj.columns[0]

        for _, lga in lga_proj.iterrows():
            lga_gap = deserts_proj.clip(lga.geometry)
            gap_area = lga_gap.area.sum() / 1e6 # Convert mÂ² to kmÂ²
            
            status = "ðŸ”´ HIGH" if gap_area > 500 else "ðŸŸ¡ MEDIUM" if gap_area > 150 else "ðŸŸ¢ LOW"
            priority_data.append({
                "LGA Name": lga[name_col],
                "Underserved Area (kmÂ²)": round(gap_area, 2),
                "Priority Status": status
            })

        priority_df = pd.DataFrame(priority_data).sort_values(by="Underserved Area (kmÂ²)", ascending=False)

        # Suggested sites: Top 3 largest contiguous gap centroids
        deserts_exploded = healthcare_deserts.explode(index_parts=False)
        top_gaps = deserts_exploded.sort_values(by=deserts_exploded.area, ascending=False).head(3)
        proposed_sites = [
            {"Proposed Site": f"Site {i+1}", "Latitude": round(g.centroid.y, 6), "Longitude": round(g.centroid.x, 6)} 
            for i, g in enumerate(top_gaps.geometry)
        ]

        return priority_df, proposed_sites

    except Exception as e:
        st.error(f"Priority Error: {str(e)}")
        return pd.DataFrame(), []
