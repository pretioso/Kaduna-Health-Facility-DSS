# -*- coding: utf-8 -*-
"""ENGINE LAYER.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1De_KA-dUY99JvldrYVRZibPQ9V7gdONe
"""

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import geopandas as gpd
import pandas as pd
import numpy as np
import networkx as nx
import libpysal as lp
from sklearn.neighbors import BallTree
from shapely.geometry import Point, MultiPoint
from matplotlib.lines import Line2D
from esda.moran import Moran

def run_analysis(facilities_df, roads_df, lga_boundary, outpatient_file):
    """
    Main analysis engine: Processes outpatient data and spatial accessibility.
    """
    # 1. Load and Clean Outpatient Data
    try:
        merged_data = pd.read_excel(outpatient_file)
    except Exception as e:
        st.error(f"Error loading Excel file: {e}")
        return None, None

    # Melt data to long format
    long_data = merged_data.melt(id_vars=["LGA", 'Year'], var_name='Month', value_name='Outpatient_Count')
    
    # Standardize LGA names
    long_data["LGA"] = (
        long_data["LGA"]
        .str.replace("^kd\s+", "", regex=True)
        .str.replace("Kaduna State", "State Total", regex=False)
        .str.replace("Local Government Area", "", regex=False)
        .str.strip()
    )

    # 2. Spatial Accessibility (Isochrones)
    # Projecting to metric system for distance calculations
    roads_metric = roads_df.to_crs(epsg=32632)
    facilities_metric = facilities_df.to_crs(epsg=32632)
    lga_metric = lga_boundary.to_crs(epsg=32632)

    # Simplified Coverage (30km buffer as proxy for 60-min travel)
    coverage_60min = facilities_metric.geometry.buffer(30000).union_all()
    coverage_df = gpd.GeoDataFrame(geometry=[coverage_60min], crs=32632).to_crs(epsg=4326)

    # Identifying Healthcare Deserts
    healthcare_deserts = gpd.overlay(
        lga_boundary.to_crs(epsg=4326),
        coverage_df,
        how='difference'
    )

    return healthcare_deserts, long_data

def calculate_priority_recommendations(lga_boundary, healthcare_deserts):
    """
    Ranks LGAs by underserved area and suggests coordinates for new facilities.
    """
    # Project to metric for area calculations
    lga_proj = lga_boundary.to_crs(epsg=32632)
    deserts_proj = healthcare_deserts.to_crs(epsg=32632)

    priority_data = []
    # Identify the correct name column (NAME_2 or LGA)
    name_col = 'NAME_2' if 'NAME_2' in lga_proj.columns else lga_proj.columns[0]

    for _, lga in lga_proj.iterrows():
        # Clip desert area to specific LGA
        lga_gap = deserts_proj.clip(lga.geometry)
        gap_area_km2 = lga_gap.area.sum() / 1e6

        status = "ðŸ”´ HIGH" if gap_area_km2 > 500 else "ðŸŸ¡ MEDIUM" if gap_area_km2 > 150 else "ðŸŸ¢ LOW"
        
        priority_data.append({
            "LGA Name": lga[name_col],
            "Underserved Area (kmÂ²)": round(gap_area_km2, 2),
            "Priority Status": status
        })

    priority_df = pd.DataFrame(priority_data).sort_values(by="Underserved Area (kmÂ²)", ascending=False)

    # Suggested GPS Locations based on desert centroids
    deserts_exploded = healthcare_deserts.explode(index_parts=False)
    top_5_gaps = deserts_exploded.sort_values(by=deserts_exploded.area, ascending=False).head(5)

    proposed_sites = []
    for i, geom in enumerate(top_5_gaps.geometry):
        proposed_sites.append({
            "Proposed Site": f"Location {i+1}",
            "Latitude": round(geom.centroid.y, 6),
            "Longitude": round(geom.centroid.x, 6)
        })

    return priority_df, proposed_sites
